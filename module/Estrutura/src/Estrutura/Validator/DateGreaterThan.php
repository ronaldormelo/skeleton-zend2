<?phpnamespace Estrutura\Validator;use Zend\Validator\AbstractValidator;use Zend\Validator\Date;use Zend\Validator\DateTime;use Zend\Validator\Exception;use Zend\ValidatorTraversable;class DateGreaterThan extends AbstractValidator{    const NOT_GREATER           = 'notGreaterThan';    const NOT_GREATER_INCLUSIVE = 'notGreaterThanInclusive';    /**     * Validation failure message template definitions     *     * @var array     */    protected $messageTemplates = array(        self::NOT_GREATER => "A data não é maior que '%min%'",        self::NOT_GREATER_INCLUSIVE => "A data não não é maior ou igual a '%min%'"    );    /**     * @var array     */    protected $messageVariables = array(        'min' => 'min',    );    /**     * Whether to do inclusive comparisons, allowing equivalence to max     *     * If false, then strict comparisons are done, and the value may equal     * the min option     *     * @var bool     */    protected $inclusive;    protected $format;    protected $reverse;    /**     * Sets validator options     *     * @param  array|Traversable $options     * @throws Exception\InvalidArgumentException     */    public function __construct($options = null)    {        if ($options instanceof Traversable) {            $options = ArrayUtils::iteratorToArray($options);        }        if (!is_array($options)) {            $options = func_get_args();            $temp['min'] = array_shift($options);            if (!empty($options)) {                $temp['inclusive'] = array_shift($options);            }            if (!empty($options)) {                $temp['format'] = array_shift($options);            }            if (!empty($options)) {                $temp['reverse'] = array_shift($options);            }            $options = $temp;        }        if (!array_key_exists('min', $options)) {            throw new Exception\InvalidArgumentException("Missing option 'min'");        }        if (!array_key_exists('inclusive', $options)) {            $options['inclusive'] = false;        }        if (!array_key_exists('format', $options)) {            $options['format'] = 'd/m/Y';        }        if (!array_key_exists('reverse', $options)) {            $options['reverse'] = 'false';        }        $this->setMin($options['min'])            ->setInclusive($options['inclusive'])            ->setFormat($options['format'])            ->setReverse($options['reverse']);        parent::__construct($options);    }    /**     * Returns the min option     *     * @return mixed     */    public function getMin()    {        return $this->min ;    }    /**     * Sets the min option     *     * @param  mixed $min     * @return GreaterThan Provides a fluent interface     */    public function setMin($min)    {        $this->min = $min instanceof \Zend\Form\Element ? $min->getValue() : $min ;        return $this;    }    /**     * Returns the inclusive option     *     * @return bool     */    public function getInclusive()    {        return $this->inclusive;    }    public function getFormat()    {        return $this->format;    }    public function getReverse()    {        return $this->reverse;    }    /**     * Sets the inclusive option     *     * @param  bool $inclusive     * @return GreaterThan Provides a fluent interface     */    public function setInclusive($inclusive)    {        $this->inclusive = $inclusive;        return $this;    }    /**     * @param $format     * @return $this     */    public function setFormat($format)    {        $this->format = $format;        return $this;    }    public function setReverse($reverse)    {        $this->reverse = $reverse;        return $this;    }    /**     * Returns true if and only if $value is greater than min option     *     * @param  mixed $value     * @return bool     */    public function isValid($value)    {        $data = new \DateTime();        $dataMaior = $data->createFromFormat($this->getFormat(),$value);        $dataMenor = $data->createFromFormat('d/m/Y',$this->getMin());        $this->setValue($dataMaior);        if ($this->inclusive) {            if ( ( !$this->getReverse() && $dataMenor > $dataMaior ) || ( $this->getReverse() && $dataMenor < $dataMaior ) ) {                $this->error(self::NOT_GREATER_INCLUSIVE);                return false;            }        } else {            if ((!$this->getReverse() && $dataMenor >= $dataMaior) || ($this->getReverse() && $dataMenor <= $dataMaior)) {                $this->error(self::NOT_GREATER);                return false;            }        }        return true;    }}